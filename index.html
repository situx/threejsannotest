<html>
<head>
<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="
  crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/three/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/TrackballControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/PLYLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/threex.domevents@1.0.1/threex.domevents.js"></script>

</head>
  <body>
    <h1>ThreeJS Annotation Test with glTF</h1>
   <span id="annocontent"></span>
   <div id="threejs" class="threejscontainer" style="max-width:485px;max-height:500px">
</div> 
  </body>
</html>
<script>$(document).ready(function(){initThreeJS('threejs',parseWKTStringToJSON("POLYGON Z ((11.914378496415974 14.386346805085239 4.228275299072266, 7.128430444339905 14.260676340056541 4.228275299072266, 6.809366923512812 19.915864141095675 4.228275299072266, 11.488962055423293 19.915864141095675 4.228275299072266, 11.914378496415974 14.386346805085239 6.769923210144043, 7.128430444339905 14.260676340056541 6.769923210144043, 6.809366923512812 19.915864141095675 6.769923210144043, 11.488962055423293 19.915864141095675 6.769923210144043, 11.914378496415974 14.386346805085239 4.228275299072266))"),["HS1185.gltf"])})</script> 

<script>

function parseWKTStringToJSON(wktstring){
    wktstring=wktstring.substring(wktstring.lastIndexOf('(')+1,wktstring.lastIndexOf(')')-1)
    resjson=[]
    for(coordset of wktstring.split(",")){
        curobject={}
        coords=coordset.trim().split(" ")
        console.log(coordset)
        console.log(coords)
        if(coords.length==3){
            resjson.push({"x":parseFloat(coords[0]),"y":parseFloat(coords[1]),"z":parseFloat(coords[2])})
        }else{
            resjson.push({"x":parseFloat(coords[0]),"y":parseFloat(coords[1])})
        }
    }
    console.log(resjson)
    return resjson
}

let camera, scene, renderer,controls;

function viewGeometry(geometry) {
  const material = new THREE.MeshPhongMaterial({
    color: 0xffffff,
    flatShading: true,
    vertexColors: THREE.VertexColors,
    wireframe: false
  });
  const mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);
}

function addPointMarker(scene,position){
	const numberTexture = new THREE.CanvasTexture(
		0
	);

	const spriteMaterial = new THREE.SpriteMaterial({
		map: numberTexture,
		alphaTest: 0.5,
		transparent: true,
		depthTest: false,
		depthWrite: false
	});

	sprite = new THREE.Sprite(spriteMaterial);
	sprite.position.set(position[0], position[1], position[2]);
	sprite.scale.set(35, 35, 1);

	scene.add(sprite);
	return scene
}

function initThreeJS(domelement,verts,meshurls) {
    scene = new THREE.Scene();
    minz=Number.MAX_VALUE
    maxz=Number.MIN_VALUE
    miny=Number.MAX_VALUE
    maxy=Number.MIN_VALUE
    minx=Number.MAX_VALUE
    maxx=Number.MIN_VALUE
	vertarray=[]
    console.log(verts)
    var svgShape = new THREE.Shape();
    first=true
    for(vert of verts){
        if(first){
            svgShape.moveTo(vert["x"], vert["y"]);
           first=false
        }else{
            svgShape.lineTo(vert["x"], vert["y"]);
        }
        vertarray.push(vert["x"])
        vertarray.push(vert["y"])
        vertarray.push(vert["z"])
        if(vert["z"]>maxz){
            maxz=vert["z"]
        }
        if(vert["z"]<minz){
            minz=vert["z"]
        }
        if(vert["y"]>maxy){
            maxy=vert["y"]
        }
        if(vert["y"]<miny){
            miny=vert["y"]
        }
        if(vert["x"]>maxx){
            maxy=vert["x"]
        }
        if(vert["x"]<minx){
            miny=vert["x"]
        }
    }
	sword=null
    if(meshurls.length>0){
        var loader = new THREE.GLTFLoader();
        loader.load(meshurls[0], function ( gltf )
		{
			sword = gltf.scene;  // sword 3D object is loaded
			//sword.scale.set(200, 200, 200);
			sword.position.x = 0;
			sword.position.y = 0;
			console.log(sword)
			if("annotations" in sword){
				console.log(sword["annotations"])
			}
			scene.add(sword);
			
		});
    }
	var raycaster = new THREE.Raycaster();
    camera = new THREE.PerspectiveCamera(90,window.innerWidth / window.innerHeight, 0.1, 150 );
    scene.add(new THREE.AmbientLight(0x222222));
    var light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(20, 20, 0);
    scene.add(light);
    var axesHelper = new THREE.AxesHelper( Math.max(maxx, maxy, maxz)*4 );
    scene.add( axesHelper );
    console.log("Depth: "+(maxz-minz))
    var extrudedGeometry = new THREE.ExtrudeGeometry(svgShape, {depth: maxz-minz, bevelEnabled: false});
    extrudedGeometry.computeBoundingBox()
    centervec=new THREE.Vector3()
    extrudedGeometry.boundingBox.getCenter(centervec)
    console.log(centervec)
    const material = new THREE.MeshBasicMaterial( { color: 0xFFFFFF, wireframe:true } );
    const mesh = new THREE.Mesh( extrudedGeometry, material );
    scene.add( mesh );
	addPointMarker(scene,[0.25,0.25,0.25])
    renderer = new THREE.WebGLRenderer( { antialias: false } );
	renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( 480, 500 );
    document.getElementById(domelement).appendChild( renderer.domElement );
	document.getElementById(domelement).addEventListener('click', function(event){
	  var bounds = document.getElementById(domelement).getBoundingClientRect()
	  console.log(bounds)
	  mouse={}
	  mouse.x = ( (event.clientX - bounds.left) / document.getElementById(domelement).clientWidth ) * 2 - 1;
	  mouse.y = - ( (event.clientY - bounds.top) / document.getElementById(domelement).clientHeight ) * 2 + 1;
	  raycaster.setFromCamera( mouse, camera );
	  var intersects = raycaster.intersectObjects(scene.children, true);
	  if (intersects.length > 0) {
	     console.log(mesh)
		 console.log(scene.children)
		 document.getElementById("annocontent").innerHTML="Clicked on point in annotation: "+mouse.x+" "+mouse.y
		 console.log("INTERSECTIONNNNNN")
	  }
	}, false)
	controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.target.set( centervec.x,centervec.y,centervec.z );
    camera.position.x= centervec.x
    camera.position.y= centervec.y
    camera.position.z = centervec.z+10;
    controls.maxDistance= Math.max(maxx, maxy, maxz)*5
    controls.update();
    animate()
}

function animate() {
    requestAnimationFrame( animate );
    controls.update();
    renderer.render( scene, camera );
}</script>
