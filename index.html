<html>
<head>
<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="
  crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/three/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/TrackballControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/PLYLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/threex.domevents@1.0.1/threex.domevents.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

</head>
  <body>
    <h1>ThreeJS Annotation Test with glTF</h1>
	<canvas id="number" width="64" height="64"></canvas>
   <span id="annocontent"></span>
   <div id="threejs" class="threejscontainer" style="max-width:485px;max-height:500px">
</div> 
  </body>
</html>
<script>$(document).ready(function(){initThreeJS('threejs',parseWKTStringToJSON("POLYGON Z ((11.914378496415974 14.386346805085239 4.228275299072266, 7.128430444339905 14.260676340056541 4.228275299072266, 6.809366923512812 19.915864141095675 4.228275299072266, 11.488962055423293 19.915864141095675 4.228275299072266, 11.914378496415974 14.386346805085239 6.769923210144043, 7.128430444339905 14.260676340056541 6.769923210144043, 6.809366923512812 19.915864141095675 6.769923210144043, 11.488962055423293 19.915864141095675 6.769923210144043, 11.914378496415974 14.386346805085239 4.228275299072266))"),["HS1185.gltf"])})</script> 

<script>
const canvas = document.getElementById('number');
const ctx = canvas.getContext('2d');
const x = 32;
const y = 32;
const radius = 30;
const startAngle = 0;
const endAngle = Math.PI * 2;

ctx.fillStyle = 'rgb(0, 0, 0)';
ctx.beginPath();
ctx.arc(x, y, radius, startAngle, endAngle);
ctx.fill();

ctx.strokeStyle = 'rgb(255, 255, 255)';
ctx.lineWidth = 3;
ctx.beginPath();
ctx.arc(x, y, radius, startAngle, endAngle);
ctx.stroke();

ctx.fillStyle = 'rgb(255, 255, 255)';
ctx.font = '32px sans-serif';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText('1', x, y);
function parseWKTStringToJSON(wktstring){
    wktstring=wktstring.substring(wktstring.lastIndexOf('(')+1,wktstring.lastIndexOf(')')-1)
    resjson=[]
    for(coordset of wktstring.split(",")){
        curobject={}
        coords=coordset.trim().split(" ")
        console.log(coordset)
        console.log(coords)
        if(coords.length==3){
            resjson.push({"x":parseFloat(coords[0]),"y":parseFloat(coords[1]),"z":parseFloat(coords[2])})
        }else{
            resjson.push({"x":parseFloat(coords[0]),"y":parseFloat(coords[1])})
        }
    }
    console.log(resjson)
    return resjson
}

let camera, scene, renderer,controls;

function viewGeometry(geometry) {
  const material = new THREE.MeshPhongMaterial({
    color: 0xffffff,
    flatShading: true,
    vertexColors: THREE.VertexColors,
    wireframe: false
  });
  const mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);
}


function addPointMarker(scene,position){
	const numberTexture = new THREE.CanvasTexture(
		 document.querySelector('#number')
	);

	const spriteMaterial = new THREE.SpriteMaterial({
		map: numberTexture,
		alphaTest: 0.5,
		transparent: true,
		depthTest: false,
		depthWrite: false
	});

	sprite = new THREE.Sprite(spriteMaterial);
	sprite.position.set(position[0], position[1], position[2]);
	sprite.scale.set(1, 1, 1);

	scene.add(sprite);
	return scene
}

function initThreeJS(domelement,verts,meshurls) {
    scene = new THREE.Scene();
    minz=Number.MAX_VALUE
    maxz=Number.MIN_VALUE
    miny=Number.MAX_VALUE
    maxy=Number.MIN_VALUE
    minx=Number.MAX_VALUE
    maxx=Number.MIN_VALUE
	vertarray=[]
	annotations=new THREE.Group();
	objects=new THREE.Group();
    console.log(verts)
    var svgShape = new THREE.Shape();
    first=true
    for(vert of verts){
        if(first){
            svgShape.moveTo(vert["x"], vert["y"]);
           first=false
        }else{
            svgShape.lineTo(vert["x"], vert["y"]);
        }
        vertarray.push(vert["x"])
        vertarray.push(vert["y"])
        vertarray.push(vert["z"])
        if(vert["z"]>maxz){
            maxz=vert["z"]
        }
        if(vert["z"]<minz){
            minz=vert["z"]
        }
        if(vert["y"]>maxy){
            maxy=vert["y"]
        }
        if(vert["y"]<miny){
            miny=vert["y"]
        }
        if(vert["x"]>maxx){
            maxy=vert["x"]
        }
        if(vert["x"]<minx){
            miny=vert["x"]
        }
    }

	const gui = new dat.GUI({autoPlace: true})
	gui.domElement.id="gui"
	const geometryFolder = gui.addFolder("Mesh");
	geometryFolder.open();
	const lightingFolder = geometryFolder.addFolder("Lighting");
	const geometryF = geometryFolder.addFolder("Geometry");
	geometryF.open();
	box=null
	if(meshurls.length>0){
        var loader = new THREE.GLTFLoader();
        loader.load(meshurls[0], function ( gltf )
		{
			box = gltf.scene;  // sword 3D object is loaded
			//sword.scale.set(200, 200, 200);
			box.position.x = 0;
			box.position.y = 0;
			console.log(box)
			//console.log(gltf)
			if("annotations" in box){
				console.log(box["annotations"])
			}



			const rotationFolder = geometryF.addFolder("Rotation");
			rotationFolder.add(box.rotation, 'x', 0, Math.PI).name("X")
			rotationFolder.add(box.rotation, 'y', 0, Math.PI).name("Y")
			rotationFolder.add(box.rotation, 'z', 0, Math.PI).name("Z")

			const scaleFolder = geometryF.addFolder("Scale");
			scaleFolder.add(box.scale, 'x', 0, 2).name("X")
			scaleFolder.add(box.scale, 'y', 0, 2).name("Y")
			scaleFolder.add(box.scale, 'z', 0, 2).name("Z")

			geometryF.close();
			objects.add(box)
			scene.add(objects);

		});
    }
	var raycaster = new THREE.Raycaster();
    camera = new THREE.PerspectiveCamera(90,window.innerWidth / window.innerHeight, 0.1, 150 );
    scene.add(new THREE.AmbientLight(0x222222));
    var light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(20, 20, 0);
    scene.add(light);
    lightingFolder.add(light.position, "x").min(-5).max(5).step(0.01).name("X Position")
	lightingFolder.add(light.position, "y").min(-5).max(5).step(0.01).name("Y Position")
	lightingFolder.add(light.position, "z").min(-5).max(5).step(0.01).name("Z Position")
	var axesHelper = new THREE.AxesHelper( Math.max(maxx, maxy, maxz)*4 );
    scene.add( axesHelper );
    console.log("Depth: "+(maxz-minz))
    var extrudedGeometry = new THREE.ExtrudeGeometry(svgShape, {depth: maxz-minz, bevelEnabled: false});
    extrudedGeometry.computeBoundingBox()
    centervec=new THREE.Vector3()
    extrudedGeometry.boundingBox.getCenter(centervec)
    console.log(centervec)
    const material = new THREE.MeshBasicMaterial( { color: 0xFFFFFF, wireframe:true } );
    const mesh = new THREE.Mesh( extrudedGeometry, material );
	annotations.add(mesh)
	scene.add(annotations)
	addPointMarker(scene,[0.5,0.5,0.5])
    renderer = new THREE.WebGLRenderer( { antialias: false } );
	renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( 480, 500 );
    document.getElementById(domelement).appendChild( renderer.domElement );
	document.getElementById(domelement).addEventListener('click', function(event){
	  var bounds = document.getElementById(domelement).getBoundingClientRect()
	  console.log(bounds)
	  mouse={}
	  mouse.x = ( (event.clientX - bounds.left) / document.getElementById(domelement).clientWidth ) * 2 - 1;
	  mouse.y = - ( (event.clientY - bounds.top) / document.getElementById(domelement).clientHeight ) * 2 + 1;
	  raycaster.setFromCamera( mouse, camera );
	  var intersects = raycaster.intersectObjects(scene.children, true);
	  if (intersects.length > 0) {
	     console.log(mesh)
		 console.log(scene.children)
		 document.getElementById("annocontent").innerHTML="Clicked on point in annotation: "+mouse.x+" "+mouse.y
		 console.log("INTERSECTIONNNNNN")
	  }
	}, false)
	controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.target.set( centervec.x,centervec.y,centervec.z );
    camera.position.x= centervec.x
    camera.position.y= centervec.y
    camera.position.z = centervec.z+10;
    controls.maxDistance= Math.max(maxx, maxy, maxz)*5
    controls.update();
	const updateCamera = () => {
		camera.updateProjectionMatrix();
	}
	const cameraFolder = geometryFolder.addFolder("Camera");
	cameraFolder.add (camera, 'fov', 1, 180).name('Zoom').onChange(updateCamera);
	gui.add(objects, 'visible').name('Meshes')
    gui.add(annotations, 'visible').name('Annotations')
	animate()
}

function animate() {
    requestAnimationFrame( animate );
    controls.update();
    renderer.render( scene, camera );
}</script>
