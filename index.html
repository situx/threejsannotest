<html>
<head>
<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="
  crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/three/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/TrackballControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/PLYLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/threex.domevents@1.0.1/threex.domevents.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

</head>
  <body>
    <h1>ThreeJS Annotation Test with glTF</h1>
	<canvas id="number" width="64" height="64" style="display:none"></canvas>
   <span id="annocontent"></span>
   <div style="display: flex;">
   <div id="threejs" class="threejscontainer" style="flex: 1;max-width:100%;max-height:90%"></div>
   <div id="threejsnav" style="flex: 1;"></div> 
   </div>
  </body>
</html>
<script>
//style="max-width:485px;max-height:500px"
$(document).ready(function(){initThreeJS('threejs',parseWKTStringToJSON("POLYGON Z ((11.914378496415974 14.386346805085239 4.228275299072266, 7.128430444339905 14.260676340056541 4.228275299072266, 6.809366923512812 19.915864141095675 4.228275299072266, 11.488962055423293 19.915864141095675 4.228275299072266, 11.914378496415974 14.386346805085239 6.769923210144043, 7.128430444339905 14.260676340056541 6.769923210144043, 6.809366923512812 19.915864141095675 6.769923210144043, 11.488962055423293 19.915864141095675 6.769923210144043, 11.914378496415974 14.386346805085239 4.228275299072266))"),["HS1185.gltf"])})</script> 

<script>
const canvas = document.getElementById('number');
const ctx = canvas.getContext('2d');
const x = 32;
const y = 32;
const radius = 30;
const startAngle = 0;
const endAngle = Math.PI * 2;

ctx.fillStyle = 'rgb(0, 0, 0)';
ctx.beginPath();
ctx.arc(x, y, radius, startAngle, endAngle);
ctx.fill();

ctx.strokeStyle = 'rgb(255, 255, 255)';
ctx.lineWidth = 3;
ctx.beginPath();
ctx.arc(x, y, radius, startAngle, endAngle);
ctx.stroke();

ctx.fillStyle = 'rgb(255, 255, 255)';
ctx.font = '32px sans-serif';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText('1', x, y);

function parseWebAnnotations(webannotations,annotations,mesh){
	for(anno in webannotations){
		if("target" in webannotations[anno]){
			if("selector" in webannotations[anno]["target"] && webannotations[anno]["target"]["selector"]["type"]=="WktSelector"){
				if("POINT" in webannotations[anno]["target"]["selector"]["value"]){
					addPointMarker(parseWKTStringToJSON(webannotations[anno]["target"]["selector"]["value"])[0],annotations)
				}else{
					prepareAnnotationFromJSON(parseWKTStringToJSON(webannotations[anno]["target"]["selector"]["value"]),annotations)
				}			
			}else if("selector" in webannotations[anno]["target"] && webannotations[anno]["target"]["selector"]["type"]=="MeshSelector"){
				theindex=webannotations[anno]["target"]["selector"]["value"]
				lookeduppoint=lookUpPointFromIndex(mesh,theindex)
				if(lookeduppoint!=null){
					addPointMarker(lookeduppoint,annotations)
				}
			}
		}
	}
}

function lookUpPointFromIndex(mesh,theindex){
	indexlength=mesh["geometry"]["attributes"]["position"]["array"].length/3
	if(theindex<indexlength){
		return {"x":mesh["geometry"]["attributes"]["position"]["array"][theindex*3],"y":mesh["geometry"]["attributes"]["position"]["array"][(theindex*3)+1],"z":mesh["geometry"]["attributes"]["position"]["array"][(theindex*3)+2]}
	}
	return null
}

function parseWKTStringToJSON(wktstring){
    wktstring=wktstring.substring(wktstring.lastIndexOf('(')+1,wktstring.lastIndexOf(')')-1)
    resjson=[]
    for(coordset of wktstring.split(",")){
        curobject={}
        coords=coordset.trim().split(" ")
        console.log(coordset)
        console.log(coords)
        if(coords.length==3){
            resjson.push({"x":parseFloat(coords[0]),"y":parseFloat(coords[1]),"z":parseFloat(coords[2])})
        }else{
            resjson.push({"x":parseFloat(coords[0]),"y":parseFloat(coords[1])})
        }
    }
    console.log(resjson)
    return resjson
}

let camera, scene, renderer,controls;


function addPointMarker(position,annotations){
	const numberTexture = new THREE.CanvasTexture(
		 document.querySelector('#number')
	);

	const spriteMaterial = new THREE.SpriteMaterial({
		map: numberTexture,
		alphaTest: 0.5,
		transparent: true,
		depthTest: false,
		depthWrite: false
	});

	sprite = new THREE.Sprite(spriteMaterial);
	sprite.position.set(position["x"], position["y"], position["z"]);
	sprite.scale.set(1, 1, 1);
	annotations.add(sprite)
	return annotations
}

function prepareAnnotationFromJSON(verts,annotations){
	var svgShape = new THREE.Shape();
    first=true
    for(vert of verts){
        if(first){
            svgShape.moveTo(vert["x"], vert["y"]);
           first=false
        }else{
            svgShape.lineTo(vert["x"], vert["y"]);
        }
        vertarray.push(vert["x"])
        vertarray.push(vert["y"])
        vertarray.push(vert["z"])
        if(vert["z"]>maxz){
            maxz=vert["z"]
        }
        if(vert["z"]<minz){
            minz=vert["z"]
        }
        if(vert["y"]>maxy){
            maxy=vert["y"]
        }
        if(vert["y"]<miny){
            miny=vert["y"]
        }
        if(vert["x"]>maxx){
            maxy=vert["x"]
        }
        if(vert["x"]<minx){
            miny=vert["x"]
        }
    }
	var extrudedGeometry = new THREE.ExtrudeGeometry(svgShape, {depth: maxz-minz, bevelEnabled: false});
    extrudedGeometry.computeBoundingBox()
    centervec=new THREE.Vector3()
    extrudedGeometry.boundingBox.getCenter(centervec)
    console.log(centervec)
    const material = new THREE.MeshBasicMaterial( { color: 0xFFFFFF, wireframe:true } );
    const mesh = new THREE.Mesh( extrudedGeometry, material );
	annotations.add(mesh)
	return annotations
}

function initThreeJS(domelement,verts,meshurls) {
    scene = new THREE.Scene();
    minz=Number.MAX_VALUE
    maxz=Number.MIN_VALUE
    miny=Number.MAX_VALUE
    maxy=Number.MIN_VALUE
    minx=Number.MAX_VALUE
    maxx=Number.MIN_VALUE
	vertarray=[]
	annotations=new THREE.Group();
	objects=new THREE.Group();
    console.log(verts)
    first=true
	annotations=prepareAnnotationFromJSON(verts,annotations)  
	const gui = new dat.GUI({autoPlace: true})
	gui.domElement.id="gui"
	const geometryFolder = gui.addFolder("Mesh");
	geometryFolder.open();
	const lightingFolder = geometryFolder.addFolder("Lighting");
	const geometryF = geometryFolder.addFolder("Geometry");
	geometryF.open();

	box=null
	if(meshurls.length>0){
        var loader = new THREE.GLTFLoader();
        loader.load(meshurls[0], function ( gltf )
		{
			box = gltf.scene;  // sword 3D object is loaded
			//sword.scale.set(200, 200, 200);
			box.position.x = 0;
			box.position.y = 0;
			console.log(box)
			//console.log(gltf)
			if("annotations" in box){
				console.log(box["annotations"])
			}

			geometryF.close();
			objects.add(box)
			scene.add(objects);
			const rotationFolder = geometryF.addFolder("Rotation");
			rotationFolder.add(objects.rotation, 'x', 0, Math.PI).name("X").onChange(
			function(){
				yourVar = this.getValue();
				scene.traverse(function(obj){
					if(obj.type === 'Mesh'){
						obj.rotation.x = yourVar;
					}});
			});
			rotationFolder.add(objects.rotation, 'y', 0, Math.PI).name("Y").onChange(
			function(){
				yourVar = this.getValue();
				scene.traverse(function(obj){
					if(obj.type === 'Mesh'){
						obj.rotation.y = yourVar;
					}});
			});
			rotationFolder.add(objects.rotation, 'z', 0, Math.PI).name("Z").onChange(
			function(){
				yourVar = this.getValue();
				scene.traverse(function(obj){
					if(obj.type === 'Mesh'){
						obj.rotation.z = yourVar;
					}});
			});

			const scaleFolder = geometryF.addFolder("Scale");
			scaleFolder.add(objects.scale, 'x', 0, 2).name("X").onChange(
			function(){
				yourVar = this.getValue();
				scene.traverse(function(obj){
					if(obj.type === 'Mesh'){
						obj.scale.x = yourVar;
					}});
			});
			scaleFolder.add(objects.scale, 'y', 0, 2).name("Y").onChange(
			function(){
				yourVar = this.getValue();
				scene.traverse(function(obj){
					if(obj.type === 'Mesh'){
						obj.scale.y = yourVar;
					}});
			});
			scaleFolder.add(objects.scale, 'z', 0, 2).name("Z").onChange(
			function(){
				yourVar = this.getValue();
				scene.traverse(function(obj){
					if(obj.type === 'Mesh'){
						obj.scale.z = yourVar;
					}});
			});
		});
    }
	var raycaster = new THREE.Raycaster();
    camera = new THREE.PerspectiveCamera(90,window.innerWidth / window.innerHeight, 0.1, 150 );
    scene.add(new THREE.AmbientLight(0x222222));
    var light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(20, 20, 0);
    scene.add(light);
    lightingFolder.add(light.position, "x").min(-5).max(5).step(0.01).name("X Position")
	lightingFolder.add(light.position, "y").min(-5).max(5).step(0.01).name("Y Position")
	lightingFolder.add(light.position, "z").min(-5).max(5).step(0.01).name("Z Position")
	var axesHelper = new THREE.AxesHelper( Math.max(maxx, maxy, maxz)*4 );
    scene.add( axesHelper );
    console.log("Depth: "+(maxz-minz))
	scene.add(annotations)
	annotations=addPointMarker({"x":0.5,"y":0.5,"z":0.5},annotations)
    renderer = new THREE.WebGLRenderer( { antialias: false } );
	renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize(0.8*window.innerWidth, 0.8*window.innerHeight);
    document.getElementById(domelement).appendChild( renderer.domElement );
	document.getElementById("threejsnav").appendChild( gui.domElement );
	document.getElementById(domelement).addEventListener('click', function(event){
	  var bounds = document.getElementById(domelement).getBoundingClientRect()
	  console.log(bounds)
	  mouse={}
	  mouse.x = ( (event.clientX - bounds.left) / document.getElementById(domelement).clientWidth ) * 2 - 1;
	  mouse.y = - ( (event.clientY - bounds.top) / document.getElementById(domelement).clientHeight ) * 2 + 1;
	  raycaster.setFromCamera( mouse, camera );
	  var intersects = raycaster.intersectObjects(scene.children, true);
	  if (intersects.length > 0) {
	     console.log(mesh)
		 console.log(scene.children)
		 document.getElementById("annocontent").innerHTML="Clicked on point in annotation: "+mouse.x+" "+mouse.y
		 console.log("INTERSECTIONNNNNN")
	  }
	}, false)
	controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.target.set( centervec.x,centervec.y,centervec.z );
    camera.position.x= centervec.x
    camera.position.y= centervec.y
    camera.position.z = centervec.z+30;
    controls.maxDistance= Math.max(maxx, maxy, maxz)*5
    controls.update();
	const updateCamera = () => {
		camera.updateProjectionMatrix();
	}
	const cameraFolder = geometryFolder.addFolder("Camera");
	cameraFolder.add (camera, 'fov', 1, 180).name('Zoom').onChange(updateCamera);
	gui.add(objects, 'visible').name('Meshes')
    gui.add(annotations, 'visible').name('Annotations')
	animate()
}

function resizeCanvasToDisplaySize() {
  const canvas = renderer.domElement;
  // look up the size the canvas is being displayed
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;

  // adjust displayBuffer size to match
  if (canvas.width !== width || canvas.height !== height) {
    // you must pass false here or three.js sadly fights the browser
    renderer.setSize(width, height, false);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();

    // update any render target sizes here
  }
}

function animate() {
	resizeCanvasToDisplaySize();
    requestAnimationFrame( animate );
    controls.update();
    renderer.render( scene, camera );
}</script>
